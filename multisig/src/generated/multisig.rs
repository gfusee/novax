#[doc = r" This module, `#mod_name_ident`, encapsulates the logic, types, and implementations"]
#[doc = r" generated from the ABI (Application Binary Interface) for interacting with a specific"]
#[doc = r" smart contract on the blockchain. It provides a convenient and type-safe way to"]
#[doc = r" deploy, call, and query the smart contract."]
#[doc = r""]
#[doc = r" The module contains several key components:"]
#[doc = r""]
#[doc = r" - **Contract Struct**: A struct representing the smart contract. It has methods for deploying"]
#[doc = r"   the contract, making calls to the contract, and querying the contract's state."]
#[doc = r" - **Call and Query Structs**: Structs that encapsulate the logic for making calls to, and"]
#[doc = r"   querying the state of, the smart contract. They provide methods for configuring parameters"]
#[doc = r"   like gas limit, EGLD value, and ESDT transfers."]
#[doc = r" - **Type Definitions**: Structs and enums representing the types defined in the smart contract's"]
#[doc = r"   ABI, with conversions between native Rust types and the managed types used in the smart contract."]
#[doc = r" - **Generated Functions for Calls and Queries**: Functions generated from the ABI for each"]
#[doc = r"   endpoint and view of the smart contract, providing a type-safe interface for interacting with"]
#[doc = r"   the contract."]
#[doc = r""]
#[doc = r" This module is generated by a macro based on the smart contract's ABI, ensuring that the"]
#[doc = r" Rust interface stays in sync with the contract's actual interface."]
#[doc = r""]
#[doc = r" # Usage"]
#[doc = r""]
#[doc = r" Typically, you would import this module and use the provided structs and functions to interact"]
#[doc = r" with the smart contract from your Rust code."]
#[doc = r""]
#[doc = r" # Note"]
#[doc = r""]
#[doc = r" The `#![allow(clippy::all)]` directive at the beginning of the module suppresses linting warnings"]
#[doc = r" from Clippy for the generated code, as the code's structure is determined by the ABI and may not"]
#[doc = r" always conform to common Rust idioms."]
pub mod multisig {
    #![allow(clippy::all)]
    #![allow(unused_imports)]
    #![allow(dead_code)]
    multiversx_sc::imports!();
    multiversx_sc::derive_imports!();
    use novax::caching::CachingNone;
    use novax::caching::CachingStrategy;
    use novax::code::AsBytesValue;
    use novax::code::DeployData;
    use novax::errors::CodingError;
    use novax::errors::NovaXError;
    use crate::generated::multisig::multisig::Proxy as CodegenProxy;
    use core::marker::PhantomData;
    use multiversx_sc::api::VMApi;
    use multiversx_sc_codec::Empty;
    use multiversx_sc_codec::TopEncodeMulti;
    use multiversx_sc_scenario::api::StaticApi;
    use multiversx_sc_scenario::imports::Bech32Address;
    use multiversx_sc_scenario::scenario_model::AddressKey;
    use multiversx_sc_scenario::scenario_model::AddressValue;
    use multiversx_sc_scenario::scenario_model::ScDeployStep;
    use multiversx_sc_scenario::scenario_model::ScQueryStep;
    use multiversx_sc_scenario::scenario_model::TxResponse;
    use multiversx_sc_scenario::ContractInfo;
    use multiversx_sc_scenario::DebugApi;
    use multiversx_sdk::wallet::Wallet;
    use novax_data::Address;
    use novax_data::ManagedConvertible;
    use novax_data::NativeConvertible;
    use novax_executor::call_result::CallResult;
    use novax_executor::DeployExecutor;
    use novax_executor::QueryExecutor;
    use novax_executor::TokenTransfer;
    use novax_executor::TransactionExecutor;
    use serde::{Deserialize, Serialize};
    use std::collections::hash_map::DefaultHasher;
    use std::hash::Hash;
    use std::hash::Hasher;
    use std::ops::Deref;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    type MultisigContractInfos = ContractInfo<CodegenProxy<StaticApi>>;
    #[allow(missing_docs)]
    mod multisig_contract_proxy {
        use super::*;
        #[multiversx_sc::proxy]
        trait MultisigContractProxy {
            #[init]
            fn init(
                &self,
                quorum: u32,
                board: MultiValueEncoded<Self::Api, ManagedAddress<Self::Api>>,
            );
            #[endpoint(deposit)]
            fn deposit(&self);
            #[endpoint(signed)]
            fn signed(&self, user: ManagedAddress<Self::Api>, action_id: u32) -> bool;
            #[endpoint(sign)]
            fn sign(&self, action_id: u32);
            #[endpoint(unsign)]
            fn unsign(&self, action_id: u32);
            #[endpoint(discardAction)]
            fn discard_action(&self, action_id: u32);
            #[endpoint(getQuorum)]
            fn get_quorum(&self) -> u32;
            #[endpoint(getNumBoardMembers)]
            fn get_num_board_members(&self) -> u32;
            #[endpoint(getNumProposers)]
            fn get_num_proposers(&self) -> u32;
            #[endpoint(getActionLastIndex)]
            fn get_action_last_index(&self) -> u32;
            #[endpoint(proposeAddBoardMember)]
            fn propose_add_board_member(
                &self,
                board_member_address: ManagedAddress<Self::Api>,
            ) -> u32;
            #[endpoint(proposeAddProposer)]
            fn propose_add_proposer(&self, proposer_address: ManagedAddress<Self::Api>) -> u32;
            #[endpoint(proposeRemoveUser)]
            fn propose_remove_user(&self, user_address: ManagedAddress<Self::Api>) -> u32;
            #[endpoint(proposeChangeQuorum)]
            fn propose_change_quorum(&self, new_quorum: u32) -> u32;
            #[endpoint(proposeTransferExecute)]
            fn propose_transfer_execute(
                &self,
                to: ManagedAddress<Self::Api>,
                egld_amount: BigUint<Self::Api>,
                function_call: MultiValueEncoded<Self::Api, ManagedBuffer<Self::Api>>,
            ) -> u32;
            #[endpoint(proposeAsyncCall)]
            fn propose_async_call(
                &self,
                to: ManagedAddress<Self::Api>,
                egld_amount: BigUint<Self::Api>,
                function_call: MultiValueEncoded<Self::Api, ManagedBuffer<Self::Api>>,
            ) -> u32;
            #[endpoint(proposeSCDeployFromSource)]
            fn propose_sc_deploy_from_source(
                &self,
                amount: BigUint<Self::Api>,
                source: ManagedAddress<Self::Api>,
                code_metadata: CodeMetadata,
                arguments: MultiValueEncoded<Self::Api, ManagedBuffer<Self::Api>>,
            ) -> u32;
            #[endpoint(proposeSCUpgradeFromSource)]
            fn propose_sc_upgrade_from_source(
                &self,
                sc_address: ManagedAddress<Self::Api>,
                amount: BigUint<Self::Api>,
                source: ManagedAddress<Self::Api>,
                code_metadata: CodeMetadata,
                arguments: MultiValueEncoded<Self::Api, ManagedBuffer<Self::Api>>,
            ) -> u32;
            #[endpoint(quorumReached)]
            fn quorum_reached(&self, action_id: u32) -> bool;
            #[endpoint(performAction)]
            fn perform_action(&self, action_id: u32) -> OptionalValue<ManagedAddress<Self::Api>>;
            #[endpoint(dnsRegister)]
            fn dns_register(
                &self,
                dns_address: ManagedAddress<Self::Api>,
                name: ManagedBuffer<Self::Api>,
            );
        }
    }
    use multisig_contract_proxy::*;
    #[doc = r" Generated smart contract interface for interacting with the deployed contract on the blockchain."]
    #[doc = r#" The name of the struct is constructed by concatenating the ABI's name field with the string "Contract"."#]
    #[doc = r""]
    #[doc = r" This struct facilitates interactions with the smart contract through the provided methods,"]
    #[doc = r" offering a native Rust interface to perform smart contract operations like querying, calling functions,"]
    #[doc = r" and deploying new instances of the contract."]
    #[doc = r""]
    #[doc = r" The struct is parameterized over a type `A` that represents an address or reference to an address,"]
    #[doc = r" where `A` is expected to be dereferenceable to a type from which an `Address` can be derived."]
    #[doc = r""]
    #[doc = r" # Methods"]
    #[doc = r""]
    #[doc = r" - `query(...)`: This method facilitates querying data from the smart contract. It accepts necessary"]
    #[doc = r" parameters as defined in the ABI and returns a result as per the ABI's specification for the particular query."]
    #[doc = r""]
    #[doc = r" - `call(...)`: This method allows for calling smart contract functions. It handles the formation of the"]
    #[doc = r" transaction, its submission to the blockchain, and returns the transaction result along with any data"]
    #[doc = r" returned by the smart contract function, as per the ABI's specification."]
    #[doc = r""]
    #[doc = r" - `deploy(...)`: This is a static method useful for deploying a new instance of the smart contract to the blockchain."]
    #[doc = r" It accepts deployment parameters as defined in the ABI, and returns an instance of the generated contract struct,"]
    #[doc = r" now associated with the newly deployed contract's address on the blockchain."]
    #[doc = r""]
    #[doc = r" # Example"]
    #[doc = r""]
    #[doc = r" ```ignore"]
    #[doc = r" let contract = #name::deploy(&deploy_executor, deploy_data)?;"]
    #[doc = r" let query_result = contract.query(&query_executor, query_data)?;"]
    #[doc = r" let call_result = contract.call(&call_executor, call_data)?;"]
    #[doc = r" ```"]
    #[doc = r""]
    #[doc = r" # Note"]
    #[doc = r""]
    #[doc = r" The actual method signatures and types will be generated based on the ABI provided."]
    #[derive(Copy, Clone)]
    pub struct MultisigContract<A>
    where
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        address: A,
    }
    #[doc = r" Struct representing a smart contract function call."]
    #[doc = r" This struct contains all necessary information to perform a function call on the smart contract,"]
    #[doc = r" including the executor to handle transaction execution, value and token transfers to be sent along with the call,"]
    #[doc = r" gas limit for the call, and the address of the contract to call."]
    #[doc = r" It has methods representing endpoints generated from the ABI."]
    #[doc = r" Additionally, convenient methods are added to set information like ESDT transfers and others."]
    #[derive(Clone, Debug)]
    pub struct MultisigContractCall<Executor, A>
    where
        Executor: TransactionExecutor,
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        executor: Executor,
        egld_value: num_bigint::BigUint,
        token_transfers: Vec<TokenTransfer>,
        gas_limit: u64,
        contract_address: A,
    }
    #[doc = r" Struct representing a smart contract query."]
    #[doc = r" This struct contains all necessary information to perform a query on the smart contract,"]
    #[doc = r" including the executor to handle query execution, the value to be sent along with the query,"]
    #[doc = r" and the address of the contract to query."]
    #[doc = r" It has methods representing views generated from the ABI."]
    #[doc = r" Additionally, a convenient method `with_caching` is provided to allow caching the result through a `CachingStrategy`."]
    #[doc = r#" By default, `CachingNone` is used, but more caching strategies can be found in the "novax-caching" crate."#]
    #[derive(Clone, Debug)]
    pub struct MultisigContractQuery<Executor, Caching, A>
    where
        Executor: QueryExecutor,
        Caching: CachingStrategy,
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        contract_address: A,
        egld_value: num_bigint::BigUint,
        executor: Executor,
        caching: Caching,
    }
    #[doc = r" The main struct representing the smart contract."]
    #[doc = r" This struct provides methods to create instances for contract call and query."]
    #[doc = r" It also provides a method for deploying a new instance of the smart contract."]
    impl<A> MultisigContract<A>
    where
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        #[doc = r" Creates a new instance of the smart contract interface with the provided address."]
        pub fn new(address: A) -> MultisigContract<A> {
            MultisigContract { address }
        }
        #[doc = r" Returns a new instance of `#call_name` struct to perform function calls on the smart contract."]
        pub fn call<Executor: TransactionExecutor>(
            self,
            executor: Executor,
            gas_limit: u64,
        ) -> MultisigContractCall<Executor, A> {
            MultisigContractCall {
                executor,
                gas_limit,
                egld_value: num_bigint::BigUint::from(0u8),
                token_transfers: vec![],
                contract_address: self.address,
            }
        }
        #[doc = r" Returns a new instance of `#query_name` struct to perform queries on the smart contract."]
        pub fn query<Executor: QueryExecutor>(
            self,
            executor: Executor,
        ) -> MultisigContractQuery<Executor, CachingNone, A> {
            MultisigContractQuery {
                contract_address: self.address,
                egld_value: num_bigint::BigUint::from(0u8),
                executor,
                caching: CachingNone,
            }
        }
    }
    impl MultisigContract<String> {
        #[doc = r" This asynchronous function encapsulates the logic for deploying a smart contract to the blockchain."]
        pub async fn deploy<Code: AsBytesValue, Executor: DeployExecutor>(
            _novax_deploy_data: DeployData<Code>,
            _novax_executor: &mut Executor,
            _novax_egld_value: num_bigint::BigUint,
            _novax_gas_limit: u64,
            quorum: &<u32 as NativeConvertible>::Native,
            board : & < MultiValueEncoded < StaticApi , ManagedAddress < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<(Address, CallResult<()>), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let mut _novax_contract = MultisigContractInfos::new(
                &multiversx_sc::types::Address::from(<[u8; 32]>::default()),
            );
            let _novax_argument_quorum: u32 = r#quorum.to_managed();
            let _novax_argument_board: MultiValueEncoded<StaticApi, ManagedAddress<StaticApi>> =
                r#board.to_managed();
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_quorum.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_board.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let _novax_code_bytes = _novax_deploy_data.code.into_bytes_value().await?;
            _novax_executor
                .sc_deploy::<()>(
                    _novax_code_bytes,
                    _novax_deploy_data.metadata,
                    _novax_egld_value,
                    _novax_bytes_args,
                    _novax_gas_limit,
                )
                .await
                .map_err(NovaXError::from)
        }
    }
    impl<Executor, Caching, A> MultisigContractQuery<Executor, Caching, A>
    where
        Executor: QueryExecutor,
        Caching: CachingStrategy,
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        #[doc = r" Modifies the caching strategy used for the query."]
        #[doc = r" This method allows changing the caching strategy to a different type,"]
        #[doc = r" useful in cases where varying levels of caching are desired."]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" * `strategy`: A reference to the new caching strategy to be used."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A new instance of `#query_name` with the updated caching strategy."]
        pub fn with_caching_strategy<C2: CachingStrategy + Clone>(
            self,
            strategy: &C2,
        ) -> MultisigContractQuery<Executor, C2, A> {
            MultisigContractQuery {
                contract_address: self.contract_address,
                executor: self.executor,
                egld_value: self.egld_value,
                caching: strategy.clone(),
            }
        }
        #[doc = r" Modifies the EGLD value associated with the query."]
        #[doc = r" This method allows setting a new EGLD value to be used in the query."]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" * `egld_value`: The new EGLD value to be used."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A new instance of `#query_name` with the updated EGLD value."]
        pub fn with_egld_value(
            self,
            egld_value: num_bigint::BigUint,
        ) -> MultisigContractQuery<Executor, Caching, A> {
            MultisigContractQuery { egld_value, ..self }
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn deposit(&mut self) -> Result<(), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "deposit".hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<()>(
                            &_novax_contract_address,
                            "deposit".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn signed(
            &mut self,
            user: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<<bool as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_user: ManagedAddress<StaticApi> = r#user.to_managed();
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_user.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "signed".hash(&mut _novax_hasher);
            user.hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<bool>(
                            &_novax_contract_address,
                            "signed".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn sign(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<(), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "sign".hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<()>(
                            &_novax_contract_address,
                            "sign".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn unsign(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<(), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "unsign".hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<()>(
                            &_novax_contract_address,
                            "unsign".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn discard_action(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<(), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "discardAction".hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<()>(
                            &_novax_contract_address,
                            "discardAction".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn get_quorum(
            &mut self,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "getQuorum".hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "getQuorum".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn get_num_board_members(
            &mut self,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "getNumBoardMembers".hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "getNumBoardMembers".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn get_num_proposers(
            &mut self,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "getNumProposers".hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "getNumProposers".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn get_action_last_index(
            &mut self,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "getActionLastIndex".hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "getActionLastIndex".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_add_board_member(
            &mut self,
            board_member_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_board_member_address: ManagedAddress<StaticApi> =
                r#board_member_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_board_member_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeAddBoardMember".hash(&mut _novax_hasher);
            board_member_address.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeAddBoardMember".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_add_proposer(
            &mut self,
            proposer_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_proposer_address: ManagedAddress<StaticApi> =
                r#proposer_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_proposer_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeAddProposer".hash(&mut _novax_hasher);
            proposer_address.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeAddProposer".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_remove_user(
            &mut self,
            user_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_user_address: ManagedAddress<StaticApi> =
                r#user_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_user_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeRemoveUser".hash(&mut _novax_hasher);
            user_address.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeRemoveUser".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_change_quorum(
            &mut self,
            new_quorum: &<u32 as NativeConvertible>::Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_new_quorum: u32 = r#new_quorum.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_new_quorum.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeChangeQuorum".hash(&mut _novax_hasher);
            new_quorum.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeChangeQuorum".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_transfer_execute(
            &mut self,
            to: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            egld_amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            function_call : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_to: ManagedAddress<StaticApi> = r#to.to_managed();
            let _novax_argument_egld_amount: BigUint<StaticApi> = r#egld_amount.to_managed();
            let _novax_argument_function_call: MultiValueEncoded<
                StaticApi,
                ManagedBuffer<StaticApi>,
            > = r#function_call.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_to.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_egld_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_function_call.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeTransferExecute".hash(&mut _novax_hasher);
            to.hash(&mut _novax_hasher);
            egld_amount.hash(&mut _novax_hasher);
            function_call.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeTransferExecute".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_async_call(
            &mut self,
            to: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            egld_amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            function_call : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_to: ManagedAddress<StaticApi> = r#to.to_managed();
            let _novax_argument_egld_amount: BigUint<StaticApi> = r#egld_amount.to_managed();
            let _novax_argument_function_call: MultiValueEncoded<
                StaticApi,
                ManagedBuffer<StaticApi>,
            > = r#function_call.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_to.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_egld_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_function_call.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeAsyncCall".hash(&mut _novax_hasher);
            to.hash(&mut _novax_hasher);
            egld_amount.hash(&mut _novax_hasher);
            function_call.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeAsyncCall".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_sc_deploy_from_source(
            &mut self,
            amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            source: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            code_metadata: &<CodeMetadata as NativeConvertible>::Native,
            arguments : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_amount: BigUint<StaticApi> = r#amount.to_managed();
            let _novax_argument_source: ManagedAddress<StaticApi> = r#source.to_managed();
            let _novax_argument_code_metadata: CodeMetadata = r#code_metadata.to_managed();
            let _novax_argument_arguments: MultiValueEncoded<StaticApi, ManagedBuffer<StaticApi>> =
                r#arguments.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_source.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_code_metadata.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_arguments.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeSCDeployFromSource".hash(&mut _novax_hasher);
            amount.hash(&mut _novax_hasher);
            source.hash(&mut _novax_hasher);
            code_metadata.hash(&mut _novax_hasher);
            arguments.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeSCDeployFromSource".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn propose_sc_upgrade_from_source(
            &mut self,
            sc_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            source: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            code_metadata: &<CodeMetadata as NativeConvertible>::Native,
            arguments : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<<u32 as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_sc_address: ManagedAddress<StaticApi> = r#sc_address.to_managed();
            let _novax_argument_amount: BigUint<StaticApi> = r#amount.to_managed();
            let _novax_argument_source: ManagedAddress<StaticApi> = r#source.to_managed();
            let _novax_argument_code_metadata: CodeMetadata = r#code_metadata.to_managed();
            let _novax_argument_arguments: MultiValueEncoded<StaticApi, ManagedBuffer<StaticApi>> =
                r#arguments.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_sc_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_source.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_code_metadata.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_arguments.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "proposeSCUpgradeFromSource".hash(&mut _novax_hasher);
            sc_address.hash(&mut _novax_hasher);
            amount.hash(&mut _novax_hasher);
            source.hash(&mut _novax_hasher);
            code_metadata.hash(&mut _novax_hasher);
            arguments.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<u32>(
                            &_novax_contract_address,
                            "proposeSCUpgradeFromSource".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn quorum_reached(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<<bool as NativeConvertible>::Native, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "quorumReached".hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<bool>(
                            &_novax_contract_address,
                            "quorumReached".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn perform_action(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<
            <OptionalValue<ManagedAddress<StaticApi>> as NativeConvertible>::Native,
            NovaXError,
        > {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "performAction".hash(&mut _novax_hasher);
            action_id.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<OptionalValue<ManagedAddress<StaticApi>>>(
                            &_novax_contract_address,
                            "performAction".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
        #[doc = r" Executes the `#function_name` query on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing the `#function_native_outputs` or a `NovaXError` if the query fails."]
        pub async fn dns_register(
            &mut self,
            dns_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            name: &<ManagedBuffer<StaticApi> as NativeConvertible>::Native,
        ) -> Result<(), NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_dns_address: ManagedAddress<StaticApi> = r#dns_address.to_managed();
            let _novax_argument_name: ManagedBuffer<StaticApi> = r#name.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_dns_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_name.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let mut _novax_hasher = DefaultHasher::new();
            _novax_contract_address_value.value.hash(&mut _novax_hasher);
            "dnsRegister".hash(&mut _novax_hasher);
            dns_address.hash(&mut _novax_hasher);
            name.hash(&mut _novax_hasher);
            let _novax_key = _novax_hasher.finish();
            self.caching
                .get_or_set_cache(_novax_key, async {
                    let result = self
                        .executor
                        .execute::<()>(
                            &_novax_contract_address,
                            "dnsRegister".to_string(),
                            _novax_bytes_args,
                            self.egld_value.clone(),
                            vec![],
                        )
                        .await;
                    if let Result::Ok(result) = result {
                        Result::Ok::<_, NovaXError>(result)
                    } else {
                        let error: NovaXError = result.unwrap_err().into();
                        Result::Err(error)
                    }
                })
                .await
        }
    }
    impl<Executor, A> MultisigContractCall<Executor, A>
    where
        Executor: TransactionExecutor,
        A: Deref + Send + Sync,
        Address: for<'a> From<&'a A::Target>,
    {
        #[doc = r" Modifies the EGLD value associated with the call."]
        #[doc = r" This method allows setting a new EGLD value for the call transaction."]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" * `egld_value`: The new EGLD value to be used."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A new instance of `#call_name` with the updated EGLD value."]
        pub fn with_egld_value(
            self,
            egld_value: num_bigint::BigUint,
        ) -> MultisigContractCall<Executor, A> {
            MultisigContractCall { egld_value, ..self }
        }
        #[doc = r" Modifies the ESDT transfers associated with the call."]
        #[doc = r" This method allows setting a new list of ESDT transfers for the call transaction."]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" * `token_transfers`: A reference to a vector of `TokenTransfer` objects representing the new ESDT transfers to be used."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A new instance of `#call_name` with the updated ESDT transfers."]
        pub fn with_esdt_transfers(
            self,
            token_transfers: &Vec<TokenTransfer>,
        ) -> MultisigContractCall<Executor, A> {
            MultisigContractCall {
                token_transfers: token_transfers.clone(),
                ..self
            }
        }
        #[doc = r" Modifies the gas limit associated with the call."]
        #[doc = r" This method allows setting a new gas limit for the call transaction."]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" * `gas_limit`: The new gas limit to be used."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A new instance of `#call_name` with the updated gas limit."]
        pub fn with_gas_limit(self, gas_limit: u64) -> MultisigContractCall<Executor, A> {
            MultisigContractCall { gas_limit, ..self }
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn deposit(&mut self) -> Result<CallResult<()>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let result = self
                .executor
                .sc_call::<()>(
                    &_novax_contract_address,
                    "deposit".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn signed(
            &mut self,
            user: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<<bool as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_user: ManagedAddress<StaticApi> = r#user.to_managed();
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_user.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<bool>(
                    &_novax_contract_address,
                    "signed".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn sign(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<()>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<()>(
                    &_novax_contract_address,
                    "sign".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn unsign(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<()>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<()>(
                    &_novax_contract_address,
                    "unsign".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn discard_action(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<()>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<()>(
                    &_novax_contract_address,
                    "discardAction".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn get_quorum(
            &mut self,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "getQuorum".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn get_num_board_members(
            &mut self,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "getNumBoardMembers".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn get_num_proposers(
            &mut self,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "getNumProposers".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn get_action_last_index(
            &mut self,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "getActionLastIndex".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_add_board_member(
            &mut self,
            board_member_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_board_member_address: ManagedAddress<StaticApi> =
                r#board_member_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_board_member_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeAddBoardMember".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_add_proposer(
            &mut self,
            proposer_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_proposer_address: ManagedAddress<StaticApi> =
                r#proposer_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_proposer_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeAddProposer".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_remove_user(
            &mut self,
            user_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_user_address: ManagedAddress<StaticApi> =
                r#user_address.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_user_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeRemoveUser".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_change_quorum(
            &mut self,
            new_quorum: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_new_quorum: u32 = r#new_quorum.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_new_quorum.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeChangeQuorum".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_transfer_execute(
            &mut self,
            to: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            egld_amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            function_call : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_to: ManagedAddress<StaticApi> = r#to.to_managed();
            let _novax_argument_egld_amount: BigUint<StaticApi> = r#egld_amount.to_managed();
            let _novax_argument_function_call: MultiValueEncoded<
                StaticApi,
                ManagedBuffer<StaticApi>,
            > = r#function_call.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_to.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_egld_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_function_call.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeTransferExecute".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_async_call(
            &mut self,
            to: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            egld_amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            function_call : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_to: ManagedAddress<StaticApi> = r#to.to_managed();
            let _novax_argument_egld_amount: BigUint<StaticApi> = r#egld_amount.to_managed();
            let _novax_argument_function_call: MultiValueEncoded<
                StaticApi,
                ManagedBuffer<StaticApi>,
            > = r#function_call.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_to.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_egld_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_function_call.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeAsyncCall".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_sc_deploy_from_source(
            &mut self,
            amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            source: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            code_metadata: &<CodeMetadata as NativeConvertible>::Native,
            arguments : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_amount: BigUint<StaticApi> = r#amount.to_managed();
            let _novax_argument_source: ManagedAddress<StaticApi> = r#source.to_managed();
            let _novax_argument_code_metadata: CodeMetadata = r#code_metadata.to_managed();
            let _novax_argument_arguments: MultiValueEncoded<StaticApi, ManagedBuffer<StaticApi>> =
                r#arguments.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_source.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_code_metadata.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_arguments.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeSCDeployFromSource".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn propose_sc_upgrade_from_source(
            &mut self,
            sc_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            amount: &<BigUint<StaticApi> as NativeConvertible>::Native,
            source: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            code_metadata: &<CodeMetadata as NativeConvertible>::Native,
            arguments : & < MultiValueEncoded < StaticApi , ManagedBuffer < StaticApi > > as NativeConvertible > :: Native,
        ) -> Result<CallResult<<u32 as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_sc_address: ManagedAddress<StaticApi> = r#sc_address.to_managed();
            let _novax_argument_amount: BigUint<StaticApi> = r#amount.to_managed();
            let _novax_argument_source: ManagedAddress<StaticApi> = r#source.to_managed();
            let _novax_argument_code_metadata: CodeMetadata = r#code_metadata.to_managed();
            let _novax_argument_arguments: MultiValueEncoded<StaticApi, ManagedBuffer<StaticApi>> =
                r#arguments.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_sc_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_amount.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_source.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_code_metadata.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_arguments.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<u32>(
                    &_novax_contract_address,
                    "proposeSCUpgradeFromSource".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn quorum_reached(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<CallResult<<bool as NativeConvertible>::Native>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<bool>(
                    &_novax_contract_address,
                    "quorumReached".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn perform_action(
            &mut self,
            action_id: &<u32 as NativeConvertible>::Native,
        ) -> Result<
            CallResult<<OptionalValue<ManagedAddress<StaticApi>> as NativeConvertible>::Native>,
            NovaXError,
        > {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_action_id: u32 = r#action_id.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_action_id.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<OptionalValue<ManagedAddress<StaticApi>>>(
                    &_novax_contract_address,
                    "performAction".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
        #[doc = r" Executes the `#function_name` function on the smart contract."]
        #[doc = r""]
        #[doc = r" # Description"]
        #[doc = r" #abi_description"]
        #[doc = r""]
        #[doc = r" # Parameters"]
        #[doc = r" #function_inputs"]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `Result` containing a `CallResult` with the `#function_native_outputs` or a `NovaXError` if the call fails."]
        pub async fn dns_register(
            &mut self,
            dns_address: &<ManagedAddress<StaticApi> as NativeConvertible>::Native,
            name: &<ManagedBuffer<StaticApi> as NativeConvertible>::Native,
        ) -> Result<CallResult<()>, NovaXError> {
            let _novax_request_arc =
                novax::utils::static_request_arc::get_static_request_arc_clone();
            let _novax_contract_address = Address::from(&self.contract_address);
            let _novax_contract_address_value: AddressValue = (&_novax_contract_address).into();
            let mut _novax_contract = MultisigContractInfos::new(&_novax_contract_address_value);
            let _novax_argument_dns_address: ManagedAddress<StaticApi> = r#dns_address.to_managed();
            let _novax_argument_name: ManagedBuffer<StaticApi> = r#name.to_managed();
            let _novax_payment = if self.egld_value > num_bigint::BigUint::from(0u8) {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(self.egld_value.clone()))
            } else {
                EgldOrMultiEsdtPayment::Egld(BigUint::<StaticApi>::from(0u8))
            };
            let mut _novax_bytes_args: std::vec::Vec<std::vec::Vec<u8>> = vec![];
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_dns_address.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            {
                let mut _novax_top_encoded_args =
                    ManagedVec::<StaticApi, ManagedBuffer<StaticApi>>::new();
                _ = _novax_argument_name.multi_encode(&mut _novax_top_encoded_args);
                for _novax_top_encoded_arg in _novax_top_encoded_args.into_iter() {
                    _novax_bytes_args.push(_novax_top_encoded_arg.to_boxed_bytes().into_vec());
                }
            }
            let result = self
                .executor
                .sc_call::<()>(
                    &_novax_contract_address,
                    "dnsRegister".to_string(),
                    _novax_bytes_args,
                    self.gas_limit,
                    self.egld_value.clone(),
                    self.token_transfers.clone(),
                )
                .await?;
            Result::Ok(result)
        }
    }
    #[doc = r" Derive implementations for the structs."]
    #[type_abi]
    #[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug)]
    #[doc = r" Represents the managed version of type `#native_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This structure encapsulates fields that have a corresponding managed representation in the smart contract."]
    #[doc = r" It's typically used internally for serialization and deserialization to and from the smart contract,"]
    #[doc = r" as well as for other operations that interact directly with the smart contract's ABI."]
    pub struct ActionFullInfoManaged {
        #[allow(missing_docs)]
        pub r#action_id: u32,
        #[allow(missing_docs)]
        pub r#action_data: ActionManaged,
        #[allow(missing_docs)]
        pub r#signers: ManagedVec<StaticApi, ManagedAddress<StaticApi>>,
    }
    #[doc = r" Represents the native version of type `#managed_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This structure encapsulates fields that have a corresponding native representation in Rust."]
    #[doc = r" It's designed for more straightforward interaction in Rust code, and can be converted to and from its"]
    #[doc = r" corresponding managed representation (`#managed_name_ident`) using the provided trait implementations."]
    #[derive(Serialize, Deserialize, PartialEq, Hash, Clone, Debug)]
    pub struct ActionFullInfo {
        #[allow(missing_docs)]
        pub r#action_id: <u32 as NativeConvertible>::Native,
        #[allow(missing_docs)]
        pub r#action_data: <ActionManaged as NativeConvertible>::Native,
        #[allow(missing_docs)]
        pub r#signers:
            <ManagedVec<StaticApi, ManagedAddress<StaticApi>> as NativeConvertible>::Native,
    }
    #[doc = r" Provides a mechanism for converting a `#managed_name_ident` to its native representation (`#native_name_ident`)."]
    impl NativeConvertible for ActionFullInfoManaged {
        type Native = ActionFullInfo;
        #[doc = r" Converts the `#managed_name_ident` to its native representation."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `#native_name_ident` instance representing the same data as the `#managed_name_ident`."]
        fn to_native(&self) -> Self::Native {
            ActionFullInfo {
                r#action_id: self.r#action_id.to_native(),
                r#action_data: self.r#action_data.to_native(),
                r#signers: self.r#signers.to_native(),
            }
        }
    }
    #[doc = r" Type alias for wrapping the managed API."]
    type ActionFullInfoManagedType = ActionFullInfoManaged;
    impl ActionFullInfo {
        #[doc = r" Constructs an instance of `#native_name_ident` from ESDT token attributes."]
        #[doc = r""]
        #[doc = r" This function attempts to decode the provided ESDT attributes into an instance of `#native_name_ident`."]
        #[doc = r" It is specifically designed to work with the attributes associated with ESDT tokens, which are typically"]
        #[doc = r" encoded in a binary format."]
        #[doc = r""]
        #[doc = r" # Arguments"]
        #[doc = r" - `attributes`: A byte slice (`&[u8]`) representing the ESDT token attributes to be decoded."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" - `Ok(#native_name_ident)`: Successfully decoded instance of `#native_name_ident`."]
        #[doc = r" - `Err(NovaXError)`: An error wrapped in `NovaXError`, specifically `CodingError::CannotDecodeEsdtAttributes`,"]
        #[doc = r"   if the decoding process fails. This error indicates that the provided attributes could not be properly"]
        #[doc = r"   decoded into the expected `#native_name_ident` type."]
        pub fn from_esdt_attributes(attributes: &[u8]) -> Result<ActionFullInfo, NovaXError> {
            let Result::Ok(decoded) = ActionFullInfoManaged::top_decode(attributes) else {
                return Result::Err(CodingError::CannotDecodeEsdtAttributes.into());
            };
            Result::Ok(decoded.to_native())
        }
    }
    #[doc = r" Provides a mechanism for converting a `#native_name_ident` to its managed representation (`#managed_name_ident`)."]
    impl ManagedConvertible<ActionFullInfoManaged> for ActionFullInfo {
        #[doc = r" Converts the `#native_name_ident` to its managed representation."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `#managed_name_ident` instance representing the same data as the `#native_name_ident`."]
        fn to_managed(&self) -> ActionFullInfoManaged {
            ActionFullInfoManagedType {
                r#action_id: self.r#action_id.to_managed(),
                r#action_data: self.r#action_data.to_managed(),
                r#signers: self.r#signers.to_managed(),
            }
        }
    }
    #[allow(missing_docs)]
    mod user_role_managed_mod {
        use super::*;
        #[doc = r" Represents the managed version of the enum `#native_name_ident` as defined in the ABI."]
        #[doc = r""]
        #[doc = r" This enum encapsulates variants that have a corresponding managed representation in the smart contract."]
        #[doc = r" It's typically used internally for serialization and deserialization to and from the smart contract,"]
        #[doc = r" as well as for other operations that interact directly with the smart contract's ABI."]
        #[type_abi]
        #[derive(
            TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug, ManagedVecItem,
        )]
        pub enum UserRoleManaged {
            None,
            Proposer,
            BoardMember,
        }
    }
    use user_role_managed_mod::*;
    #[doc = r" Represents the native version of the enum `#managed_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This enum encapsulates variants that have a corresponding native representation in Rust."]
    #[doc = r" It's designed for more straightforward interaction in Rust code, and can be converted to and from its"]
    #[doc = r" corresponding managed representation (`#managed_name_ident`) using the provided trait implementations."]
    #[derive(Serialize, Deserialize, PartialEq, Hash, Clone, Debug)]
    pub enum UserRole {
        #[allow(missing_docs)]
        None,
        #[allow(missing_docs)]
        Proposer,
        #[allow(missing_docs)]
        BoardMember,
    }
    impl UserRole {
        #[doc = r" Constructs an instance of `#native_name_ident` from ESDT token attributes."]
        #[doc = r""]
        #[doc = r" This function attempts to decode the provided ESDT attributes into an instance of `#native_name_ident`."]
        #[doc = r" It is specifically designed to work with the attributes associated with ESDT tokens, which are typically"]
        #[doc = r" encoded in a binary format."]
        #[doc = r""]
        #[doc = r" # Arguments"]
        #[doc = r" - `attributes`: A byte slice (`&[u8]`) representing the ESDT token attributes to be decoded."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" - `Ok(#native_name_ident)`: Successfully decoded instance of `#native_name_ident`."]
        #[doc = r" - `Err(NovaXError)`: An error wrapped in `NovaXError`, specifically `CodingError::CannotDecodeEsdtAttributes`,"]
        #[doc = r"   if the decoding process fails. This error indicates that the provided attributes could not be properly"]
        #[doc = r"   decoded into the expected `#native_name_ident` type."]
        pub fn from_esdt_attributes(attributes: &[u8]) -> Result<UserRole, NovaXError> {
            let Result::Ok(decoded) = UserRoleManaged::top_decode(attributes) else {
                return Result::Err(CodingError::CannotDecodeEsdtAttributes.into());
            };
            Result::Ok(decoded.to_native())
        }
    }
    impl NativeConvertible for UserRoleManaged {
        type Native = UserRole;
        fn to_native(&self) -> Self::Native {
            match self {
                UserRoleManaged::None => UserRole::None,
                UserRoleManaged::Proposer => UserRole::Proposer,
                UserRoleManaged::BoardMember => UserRole::BoardMember,
            }
        }
    }
    impl ManagedConvertible<UserRoleManaged> for UserRole {
        fn to_managed(&self) -> UserRoleManaged {
            match self {
                UserRole::None => UserRoleManaged::None,
                UserRole::Proposer => UserRoleManaged::Proposer,
                UserRole::BoardMember => UserRoleManaged::BoardMember,
            }
        }
    }
    impl UserRole {
        #[doc = r" This function converts an enum variant to its discriminant (u8) representation as per the"]
        #[doc = r" smart contract's understanding. Each variant is mapped to a unique u8 value starting from 0,"]
        #[doc = r" incrementing by 1 for each subsequent variant."]
        #[doc = r""]
        #[doc = r" # Errors"]
        #[doc = r" Returns `NovaXError` if the conversion fails, which could occur if the enum has a variant"]
        #[doc = r" that is not accounted for in the conversion logic."]
        pub fn to_discriminant(&self) -> Result<u8, NovaXError> {
            match self {
                UserRole::None { .. } => Result::Ok(0u8),
                UserRole::Proposer { .. } => Result::Ok(1u8),
                UserRole::BoardMember { .. } => Result::Ok(2u8),
            }
        }
    }
    #[doc = r" Derive implementations for the structs."]
    #[type_abi]
    #[derive(
        TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug, ManagedVecItem,
    )]
    #[doc = r" Represents the managed version of type `#native_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This structure encapsulates fields that have a corresponding managed representation in the smart contract."]
    #[doc = r" It's typically used internally for serialization and deserialization to and from the smart contract,"]
    #[doc = r" as well as for other operations that interact directly with the smart contract's ABI."]
    pub struct CallActionDataManaged {
        #[allow(missing_docs)]
        pub r#to: ManagedAddress<StaticApi>,
        #[allow(missing_docs)]
        pub r#egld_amount: BigUint<StaticApi>,
        #[allow(missing_docs)]
        pub r#endpoint_name: ManagedBuffer<StaticApi>,
        #[allow(missing_docs)]
        pub r#arguments: ManagedVec<StaticApi, ManagedBuffer<StaticApi>>,
    }
    #[doc = r" Represents the native version of type `#managed_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This structure encapsulates fields that have a corresponding native representation in Rust."]
    #[doc = r" It's designed for more straightforward interaction in Rust code, and can be converted to and from its"]
    #[doc = r" corresponding managed representation (`#managed_name_ident`) using the provided trait implementations."]
    #[derive(Serialize, Deserialize, PartialEq, Hash, Clone, Debug)]
    pub struct CallActionData {
        #[allow(missing_docs)]
        pub r#to: <ManagedAddress<StaticApi> as NativeConvertible>::Native,
        #[allow(missing_docs)]
        pub r#egld_amount: <BigUint<StaticApi> as NativeConvertible>::Native,
        #[allow(missing_docs)]
        pub r#endpoint_name: <ManagedBuffer<StaticApi> as NativeConvertible>::Native,
        #[allow(missing_docs)]
        pub r#arguments:
            <ManagedVec<StaticApi, ManagedBuffer<StaticApi>> as NativeConvertible>::Native,
    }
    #[doc = r" Provides a mechanism for converting a `#managed_name_ident` to its native representation (`#native_name_ident`)."]
    impl NativeConvertible for CallActionDataManaged {
        type Native = CallActionData;
        #[doc = r" Converts the `#managed_name_ident` to its native representation."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `#native_name_ident` instance representing the same data as the `#managed_name_ident`."]
        fn to_native(&self) -> Self::Native {
            CallActionData {
                r#to: self.r#to.to_native(),
                r#egld_amount: self.r#egld_amount.to_native(),
                r#endpoint_name: self.r#endpoint_name.to_native(),
                r#arguments: self.r#arguments.to_native(),
            }
        }
    }
    #[doc = r" Type alias for wrapping the managed API."]
    type CallActionDataManagedType = CallActionDataManaged;
    impl CallActionData {
        #[doc = r" Constructs an instance of `#native_name_ident` from ESDT token attributes."]
        #[doc = r""]
        #[doc = r" This function attempts to decode the provided ESDT attributes into an instance of `#native_name_ident`."]
        #[doc = r" It is specifically designed to work with the attributes associated with ESDT tokens, which are typically"]
        #[doc = r" encoded in a binary format."]
        #[doc = r""]
        #[doc = r" # Arguments"]
        #[doc = r" - `attributes`: A byte slice (`&[u8]`) representing the ESDT token attributes to be decoded."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" - `Ok(#native_name_ident)`: Successfully decoded instance of `#native_name_ident`."]
        #[doc = r" - `Err(NovaXError)`: An error wrapped in `NovaXError`, specifically `CodingError::CannotDecodeEsdtAttributes`,"]
        #[doc = r"   if the decoding process fails. This error indicates that the provided attributes could not be properly"]
        #[doc = r"   decoded into the expected `#native_name_ident` type."]
        pub fn from_esdt_attributes(attributes: &[u8]) -> Result<CallActionData, NovaXError> {
            let Result::Ok(decoded) = CallActionDataManaged::top_decode(attributes) else {
                return Result::Err(CodingError::CannotDecodeEsdtAttributes.into());
            };
            Result::Ok(decoded.to_native())
        }
    }
    #[doc = r" Provides a mechanism for converting a `#native_name_ident` to its managed representation (`#managed_name_ident`)."]
    impl ManagedConvertible<CallActionDataManaged> for CallActionData {
        #[doc = r" Converts the `#native_name_ident` to its managed representation."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" A `#managed_name_ident` instance representing the same data as the `#native_name_ident`."]
        fn to_managed(&self) -> CallActionDataManaged {
            CallActionDataManagedType {
                r#to: self.r#to.to_managed(),
                r#egld_amount: self.r#egld_amount.to_managed(),
                r#endpoint_name: self.r#endpoint_name.to_managed(),
                r#arguments: self.r#arguments.to_managed(),
            }
        }
    }
    #[allow(missing_docs)]
    mod action_managed_mod {
        use super::*;
        #[doc = r" Represents the managed version of the enum `#native_name_ident` as defined in the ABI."]
        #[doc = r""]
        #[doc = r" This enum encapsulates variants that have a corresponding managed representation in the smart contract."]
        #[doc = r" It's typically used internally for serialization and deserialization to and from the smart contract,"]
        #[doc = r" as well as for other operations that interact directly with the smart contract's ABI."]
        #[type_abi]
        #[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug)]
        pub enum ActionManaged {
            Nothing,
            AddBoardMember(ManagedAddress<StaticApi>),
            AddProposer(ManagedAddress<StaticApi>),
            RemoveUser(ManagedAddress<StaticApi>),
            ChangeQuorum(u32),
            SendTransferExecute(CallActionDataManaged),
            SendAsyncCall(CallActionDataManaged),
            SCDeployFromSource {
                r#amount: BigUint<StaticApi>,
                r#source: ManagedAddress<StaticApi>,
                r#code_metadata: CodeMetadata,
                r#arguments: ManagedVec<StaticApi, ManagedBuffer<StaticApi>>,
            },
            SCUpgradeFromSource {
                r#sc_address: ManagedAddress<StaticApi>,
                r#amount: BigUint<StaticApi>,
                r#source: ManagedAddress<StaticApi>,
                r#code_metadata: CodeMetadata,
                r#arguments: ManagedVec<StaticApi, ManagedBuffer<StaticApi>>,
            },
        }
    }
    use action_managed_mod::*;

    #[doc = r" Represents the native version of the enum `#managed_name_ident` as defined in the ABI."]
    #[doc = r""]
    #[doc = r" This enum encapsulates variants that have a corresponding native representation in Rust."]
    #[doc = r" It's designed for more straightforward interaction in Rust code, and can be converted to and from its"]
    #[doc = r" corresponding managed representation (`#managed_name_ident`) using the provided trait implementations."]
    #[derive(Serialize, Deserialize, PartialEq, Hash, Clone, Debug)]
    pub enum Action {
        #[allow(missing_docs)]
        Nothing,
        #[allow(missing_docs)]
        AddBoardMember(<ManagedAddress<StaticApi> as NativeConvertible>::Native),
        #[allow(missing_docs)]
        AddProposer(<ManagedAddress<StaticApi> as NativeConvertible>::Native),
        #[allow(missing_docs)]
        RemoveUser(<ManagedAddress<StaticApi> as NativeConvertible>::Native),
        #[allow(missing_docs)]
        ChangeQuorum(<u32 as NativeConvertible>::Native),
        #[allow(missing_docs)]
        SendTransferExecute(<CallActionDataManaged as NativeConvertible>::Native),
        #[allow(missing_docs)]
        SendAsyncCall(<CallActionDataManaged as NativeConvertible>::Native),
        #[allow(missing_docs)]
        SCDeployFromSource {
            r#amount: <BigUint<StaticApi> as NativeConvertible>::Native,
            r#source: <ManagedAddress<StaticApi> as NativeConvertible>::Native,
            r#code_metadata: <CodeMetadata as NativeConvertible>::Native,
            r#arguments:
                <ManagedVec<StaticApi, ManagedBuffer<StaticApi>> as NativeConvertible>::Native,
        },
        #[allow(missing_docs)]
        SCUpgradeFromSource {
            r#sc_address: <ManagedAddress<StaticApi> as NativeConvertible>::Native,
            r#amount: <BigUint<StaticApi> as NativeConvertible>::Native,
            r#source: <ManagedAddress<StaticApi> as NativeConvertible>::Native,
            r#code_metadata: <CodeMetadata as NativeConvertible>::Native,
            r#arguments:
                <ManagedVec<StaticApi, ManagedBuffer<StaticApi>> as NativeConvertible>::Native,
        },
    }
    impl Action {
        #[doc = r" Constructs an instance of `#native_name_ident` from ESDT token attributes."]
        #[doc = r""]
        #[doc = r" This function attempts to decode the provided ESDT attributes into an instance of `#native_name_ident`."]
        #[doc = r" It is specifically designed to work with the attributes associated with ESDT tokens, which are typically"]
        #[doc = r" encoded in a binary format."]
        #[doc = r""]
        #[doc = r" # Arguments"]
        #[doc = r" - `attributes`: A byte slice (`&[u8]`) representing the ESDT token attributes to be decoded."]
        #[doc = r""]
        #[doc = r" # Returns"]
        #[doc = r" - `Ok(#native_name_ident)`: Successfully decoded instance of `#native_name_ident`."]
        #[doc = r" - `Err(NovaXError)`: An error wrapped in `NovaXError`, specifically `CodingError::CannotDecodeEsdtAttributes`,"]
        #[doc = r"   if the decoding process fails. This error indicates that the provided attributes could not be properly"]
        #[doc = r"   decoded into the expected `#native_name_ident` type."]
        pub fn from_esdt_attributes(attributes: &[u8]) -> Result<Action, NovaXError> {
            let Result::Ok(decoded) = ActionManaged::top_decode(attributes) else {
                return Result::Err(CodingError::CannotDecodeEsdtAttributes.into());
            };
            Result::Ok(decoded.to_native())
        }
    }
    impl NativeConvertible for ActionManaged {
        type Native = Action;
        fn to_native(&self) -> Self::Native {
            match self {
                ActionManaged::Nothing => Action::Nothing,
                ActionManaged::AddBoardMember(field_0) => {
                    Action::AddBoardMember(field_0.to_native())
                }
                ActionManaged::AddProposer(field_0) => Action::AddProposer(field_0.to_native()),
                ActionManaged::RemoveUser(field_0) => Action::RemoveUser(field_0.to_native()),
                ActionManaged::ChangeQuorum(field_0) => Action::ChangeQuorum(field_0.to_native()),
                ActionManaged::SendTransferExecute(field_0) => {
                    Action::SendTransferExecute(field_0.to_native())
                }
                ActionManaged::SendAsyncCall(field_0) => Action::SendAsyncCall(field_0.to_native()),
                ActionManaged::SCDeployFromSource {
                    amount,
                    source,
                    code_metadata,
                    arguments,
                } => Action::SCDeployFromSource {
                    amount: amount.to_native(),
                    source: source.to_native(),
                    code_metadata: code_metadata.to_native(),
                    arguments: arguments.to_native(),
                },
                ActionManaged::SCUpgradeFromSource {
                    sc_address,
                    amount,
                    source,
                    code_metadata,
                    arguments,
                } => Action::SCUpgradeFromSource {
                    sc_address: sc_address.to_native(),
                    amount: amount.to_native(),
                    source: source.to_native(),
                    code_metadata: code_metadata.to_native(),
                    arguments: arguments.to_native(),
                },
            }
        }
    }
    impl ManagedConvertible<ActionManaged> for Action {
        fn to_managed(&self) -> ActionManaged {
            match self {
                Action::Nothing => ActionManaged::Nothing,
                Action::AddBoardMember(field_0) => {
                    ActionManaged::AddBoardMember(field_0.to_managed())
                }
                Action::AddProposer(field_0) => ActionManaged::AddProposer(field_0.to_managed()),
                Action::RemoveUser(field_0) => ActionManaged::RemoveUser(field_0.to_managed()),
                Action::ChangeQuorum(field_0) => ActionManaged::ChangeQuorum(field_0.to_managed()),
                Action::SendTransferExecute(field_0) => {
                    ActionManaged::SendTransferExecute(field_0.to_managed())
                }
                Action::SendAsyncCall(field_0) => {
                    ActionManaged::SendAsyncCall(field_0.to_managed())
                }
                Action::SCDeployFromSource {
                    amount,
                    source,
                    code_metadata,
                    arguments,
                } => ActionManaged::SCDeployFromSource {
                    amount: amount.to_managed(),
                    source: source.to_managed(),
                    code_metadata: code_metadata.to_managed(),
                    arguments: arguments.to_managed(),
                },
                Action::SCUpgradeFromSource {
                    sc_address,
                    amount,
                    source,
                    code_metadata,
                    arguments,
                } => ActionManaged::SCUpgradeFromSource {
                    sc_address: sc_address.to_managed(),
                    amount: amount.to_managed(),
                    source: source.to_managed(),
                    code_metadata: code_metadata.to_managed(),
                    arguments: arguments.to_managed(),
                },
            }
        }
    }
    impl Action {
        #[doc = r" This function converts an enum variant to its discriminant (u8) representation as per the"]
        #[doc = r" smart contract's understanding. Each variant is mapped to a unique u8 value starting from 0,"]
        #[doc = r" incrementing by 1 for each subsequent variant."]
        #[doc = r""]
        #[doc = r" # Errors"]
        #[doc = r" Returns `NovaXError` if the conversion fails, which could occur if the enum has a variant"]
        #[doc = r" that is not accounted for in the conversion logic."]
        pub fn to_discriminant(&self) -> Result<u8, NovaXError> {
            match self {
                Action::Nothing { .. } => Result::Ok(0u8),
                Action::AddBoardMember { .. } => Result::Ok(1u8),
                Action::AddProposer { .. } => Result::Ok(2u8),
                Action::RemoveUser { .. } => Result::Ok(3u8),
                Action::ChangeQuorum { .. } => Result::Ok(4u8),
                Action::SendTransferExecute { .. } => Result::Ok(5u8),
                Action::SendAsyncCall { .. } => Result::Ok(6u8),
                Action::SCDeployFromSource { .. } => Result::Ok(7u8),
                Action::SCUpgradeFromSource { .. } => Result::Ok(8u8),
            }
        }
    }
}
